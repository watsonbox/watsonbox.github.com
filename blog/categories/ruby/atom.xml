<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Watsonbox]]></title>
  <link href="http://watsonbox.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://watsonbox.github.com/"/>
  <updated>2015-02-16T18:11:16+01:00</updated>
  <id>http://watsonbox.github.com/</id>
  <author>
    <name><![CDATA[Howard Wilson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby speech recognition with Pocketsphinx]]></title>
    <link href="http://watsonbox.github.com/blog/2014/10/24/ruby-speech-recognition-with-pocketsphinx/"/>
    <updated>2014-10-24T15:42:02+02:00</updated>
    <id>http://watsonbox.github.com/blog/2014/10/24/ruby-speech-recognition-with-pocketsphinx</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/watsonbox/pocketsphinx-ruby">pocketsphinx-ruby</a> is a high-level Ruby wrapper for the pocketsphinx C API. It uses the Ruby Foreign Function Interface (FFI) to directly load and call functions in libpocketsphinx, as well as libsphinxav for recoding live audio using a number of different audio backends.</p>

<p>The goal of the project is to make it as easy as possible for the Ruby community to experiment with speech recognition, in particular for use in grammar-based command and control applications. Setting up a real time recognizer is as simple as:</p>

<p>```ruby
configuration = Pocketsphinx::Configuration::Grammar.new do
  sentence &ldquo;Go forward ten meters&rdquo;
  sentence &ldquo;Go backward ten meters&rdquo;
end</p>

<p>Pocketsphinx::LiveSpeechRecognizer.new(configuration).recognize do |speech|
  puts speech
end
```</p>

<p>This library supports Ruby MRI 1.9.3+, JRuby, and Rubinius. It depends on the current development versions of Pocketsphinx and Sphinxbase &ndash; there are <a href="https://github.com/watsonbox/homebrew-cmu-sphinx">Homebrew recipes</a> available for a quick start on OSX.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lazy and Partial Data Loading with Ember.js and Rails]]></title>
    <link href="http://watsonbox.github.com/blog/2014/06/13/lazy-and-partial-data-loading-with-ember-dot-js-and-rails/"/>
    <updated>2014-06-13T14:43:13+02:00</updated>
    <id>http://watsonbox.github.com/blog/2014/06/13/lazy-and-partial-data-loading-with-ember-dot-js-and-rails</id>
    <content type="html"><![CDATA[<p>While learning <a href="http://emberjs.com/">Ember.js</a>, I couldn&rsquo;t find all the info laid out clearly in one place on these subjects, so thought I&rsquo;d write up my findings. I&rsquo;m using Ember.js 1.5.1, Ember Data 1.0.0-beta.7+canary.f482da04 (!!), and Rails 4.1.0.</p>

<h2>Lazy Loading Relationships</h2>

<p>Most of the <a href="http://emberjs.com/api/data/classes/DS.ActiveModelSerializer.html">Rails/Ember guidelines</a> out there suggest that related data should normally be sideloaded, which is great and helps reduce the number of HTTP requests required, or data duplication (in the case of embedded data). To sideload data, set up the relationship and Rails serializer as follows:</p>

<p><code>coffeescript app/assets/javascripts/models/project.js.coffee
App.Project = DS.Model.extend
  name: DS.attr('string')
  description: DS.attr('string')
  invoices: DS.hasMany('invoice')
</code></p>

<p><code>ruby app/serializers/project_serializer.rb
class ProjectSerializer &lt; ActiveModel::Serializer
  attributes :id, :name
  has_many :invoices, embed: :ids, include: true # Sideload relationship
end
</code></p>

<p>``` json Example JSON Response
{
  &ldquo;projects&rdquo;: [</p>

<pre><code>{ "id": 1, "name": "Project 1", "description": "...", "invoice_ids": [1, 2] }
</code></pre>

<p>  ],
  &ldquo;invoices&rdquo;: [</p>

<pre><code>{ "id": 2, "reference": "INV-002", "date": "2014-06-11", "project_id": 1 },
{ "id": 1, "reference": "INV-001", "date": "2014-04-04", "project_id": 1 }
</code></pre>

<p>  ]
}
```</p>

<h3>Async Loading</h3>

<p>Often we&rsquo;d prefer to lazily load the associated data only when it&rsquo;s referenced. Ember Data calls this an async relationship. Simply modify the above by omitting the <code>include</code> serializer option and adding <code>async</code> to the relationship:</p>

<p><code>coffeescript app/assets/javascripts/models/project.js.coffee (partial)
invoices: DS.hasMany('invoice', { async: true })
</code></p>

<p><code>ruby app/serializers/lazy_project_serializer.rb (partial)
has_many :invoices, embed: :ids
</code></p>

<p>``` json Example JSON Response
{
  &ldquo;projects&rdquo;: [</p>

<pre><code>{ "id": 1, "name": "Project 1", "description": "...", "invoice_ids": [1, 2] }
</code></pre>

<p>  ]
}
```</p>

<p>When the <code>invoices</code> relationship is accessed, Ember Data will automatically make a request to <code>/invoices?ids[]=1&amp;ids[]=2</code> (or presumably wherever that route is defined), so the Rails <code>InvoicesController</code> must be set up to restrict returned data based on the <code>ids</code> parameter.</p>

<p><em>Update 30/12/14: Since Ember Data v1.0.0-beta.9 <a href="http://emberjs.com/blog/2014/08/18/ember-data-1-0-beta-9-released.html">has many coalescing has become opt-in</a>. This means setting <code>coalesceFindRequests: true</code> on the REST adapter for the above behavior. Thanks to CamonZ for pointing this out.</em></p>

<p>Note that if an association is set to <code>async</code>, but sideloaded data exists in the server response, Ember Data will simply use that data and not attempt to make another request. This is useful, allowing data to be sideloaded for a detail view because we know we&rsquo;re going to need it, but not for a list view where it might not be used. When moving from list to detail, the invoices will be loaded, but when arriving directly on the detail page, only the project will be loaded. Specify a different serializer in Rails for each action:</p>

<p>``` ruby app/controllers/projects_controller.rb
class ProjectsController &lt; ApplicationController
  respond_to :json</p>

<p>  def index</p>

<pre><code>respond_with Project.all, each_serializer: LazyProjectSerializer
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>respond_with Project.find(params[:id])
</code></pre>

<p>  end
end
```</p>

<h3>Async Loading From Links</h3>

<p>Another possibility, which gives more control over association endpoints, and avoids having to pass a bunch of IDs around, is to provide links for the relationships in the JSON response. For example:</p>

<p>``` ruby app/serializers/project_serializer.rb
class ProjectSerializer &lt; ActiveModel::Serializer
  attributes :id, :name, :links</p>

<p>  def links</p>

<pre><code>{ invoices: project_invoices_path(id) }
</code></pre>

<p>  end
end
```</p>

<h2>Loading Partial Models</h2>

<p>Imagine that we have a dropdown list of projects in the page navbar. In addition to lazy loading related data, we might also want to omit attributes we know we&rsquo;re not going to need yet. In this case a large project description might be a candidate for ommission from the list view, especially if the list of projects is large. The most comprehensive description of this problem I was able to find is <a href="http://discuss.emberjs.com/t/loading-partial-models-then-filling-them-with-ember-data/819">here</a>, and includes links to related discussions.</p>

<p>Firstly we need to identify the list data as partial by adding a <code>partial</code> attribute and setting it in a <code>PartialProjectSerializer</code>. We also ommit the invoices and description:</p>

<p><code>coffeescript app/assets/javascripts/models/project.js.coffee
App.Project = DS.Model.extend
  name: DS.attr('string')
  description: DS.attr('string')
  partial: DS.attr('boolean')
  invoices: DS.hasMany('invoice', { async: true })
</code></p>

<p>``` ruby app/serializers/partial_project_serializer.rb
class PartialProjectSerializer &lt; ApplicationSerializer
  attributes :id, :name, :partial</p>

<p>  def partial</p>

<pre><code>true
</code></pre>

<p>  end
end
```</p>

<p>We now have two problems to solve:</p>

<ol>
<li>Reload a complete model for the detail view if we have only a partial model.</li>
<li>Don&rsquo;t allow partial list data to overwrite a complete model if it comes in afterwards. You can simulate this in your dev environment using a threaded web server such as Puma and setting a delay on the resource index.</li>
</ol>


<p>For the first we can use <code>setupController</code> on the project route. Modifying the <code>model</code> hook won&rsquo;t work when a model is passed for example to <code>link-to</code> because it <a href="http://emberjs.com/guides/routing/asynchronous-routing/#toc_beforemodel-and-aftermodel">doesn&rsquo;t get called</a>.</p>

<p>``` coffeescript app/assets/javascripts/routes/project_route.js.coffee
Facture.ProjectRoute = Ember.Route.extend
  model: (params) &ndash;></p>

<pre><code>@store.find 'project', params.project_id
</code></pre>

<p>  setupController: (controller, model) &ndash;></p>

<pre><code># If the model is partial, we'll refresh it (from the full project resource)
model.reload() if model.get 'partial'
controller.set 'model', model
</code></pre>

<p>```</p>

<p>It would be nice if we could solve the second problem by asking Ember Data to retrieve and <em>merge</em> data from the server (using something like <code>Store#find_and_update</code>), but that doesn&rsquo;t appear to be possible. It is however possible to update individual records using <a href="http://emberjs.com/api/data/classes/DS.Store.html#method_update"><code>Store#update</code></a>.</p>

<p>I&rsquo;ve been getting these projects in the <code>ApplicationRoute</code>, which now looks like this:</p>

<p>``` coffeescript app/assets/javascripts/routes/application.js.coffee
Facture.ApplicationRoute = Ember.Route.extend
  setupController: (controller) &ndash;></p>

<pre><code>$.getJSON '/projects.json', (data) =&gt;
  # Update records in the store
  projects = data['projects'].map (project) =&gt;
    # Don't merge partial=true
    if existing_project = @store.getById('project', project.id)
      project.partial = false unless existing_project.get('partial')

    @store.update 'project', project

  # Set all records on the controller
  controller.set 'projects', projects
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Confreaks XBMC Addon 0.3.0]]></title>
    <link href="http://watsonbox.github.com/blog/2014/03/25/confreaks-xbmc-addon-0-dot-3-0/"/>
    <updated>2014-03-25T12:30:25+01:00</updated>
    <id>http://watsonbox.github.com/blog/2014/03/25/confreaks-xbmc-addon-0-dot-3-0</id>
    <content type="html"><![CDATA[<p>I finally got around to updating <a href="https://github.com/watsonbox/xbmc-confreaks">xbmc-confreaks</a> to work properly with XBMC Frodo and Gotham. This time I&rsquo;ve also submitted it to the official XBMC Addons repository so as of yesterday you should be able to install it through &lsquo;Get Addons&rsquo; in XBMC itself. Be aware that you might need to refresh the repository (right click) first.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails &amp; PHP Session Sharing #2]]></title>
    <link href="http://watsonbox.github.com/blog/2012/07/24/rails-and-php-session-sharing-number-2/"/>
    <updated>2012-07-24T16:37:00+02:00</updated>
    <id>http://watsonbox.github.com/blog/2012/07/24/rails-and-php-session-sharing-number-2</id>
    <content type="html"><![CDATA[<p>Back in May I <a href="/blog/2012/05/01/sharing-session-between-rails-and-php/">posted</a> on how I set up shared sessions between Rails and a legacy PHP app. Since then I&rsquo;ve upgraded memcache-client to Mike Perham&rsquo;s replacement, <a href="https://github.com/mperham/dalli/">Dalli</a>. I took this opportunity to tidy up the PHP session store as well. Here is what I have now:</p>

<p><div><script src='https://gist.github.com/3170415.js'></script>
<noscript><pre><code>require 'action_dispatch/middleware/session/dalli_store'

# - PHP side is 5.3.6 configured with session.save_handler = memcache
# - Requires php-serialize gem for serialization: https://github.com/jqr/php-serialize
module ActionDispatch
  module Session
    class PhpDalliStore &lt; ActionDispatch::Session::DalliStore
      require 'php_serialize'

      class PhpSerializingPoolDecorator &lt; SimpleDelegator
        def set(key, value, ttl = nil, options = nil)
          super(key, PHP.serialize_session(value), 0, :raw =&gt; true)
        end

        def get(key, options = nil)
          value = super(key)
          PHP.unserialize(value) if value &amp;&amp; value != ''
        end
      end

      def initialize(app, options = {})
        # Default to no namespace and cookie name matching PHP settings
        super(app, options.merge(:namespace =&gt; nil, :key =&gt; 'PHPSESSID'))

        # Decorate the pool to do some serialization
        @pool = PhpSerializingPoolDecorator.new(@pool)
      end
    end
  end
end</code></pre></noscript></div>
</p>

<p>This is cleaner than what I had before and should be much more resistant to changes in Dalli, too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Confreaks XBMC Addon]]></title>
    <link href="http://watsonbox.github.com/blog/2012/05/19/confreaks-xbmc-addon/"/>
    <updated>2012-05-19T22:06:00+02:00</updated>
    <id>http://watsonbox.github.com/blog/2012/05/19/confreaks-xbmc-addon</id>
    <content type="html"><![CDATA[<p>Today I wrote a little plugin for watching <a href="http://www.confreaks.com/">Confreaks</a> Ruby presentations in <a href="http://www.xbmc.org/">XBMC</a>.</p>

<p>As luck would have it, Jonathan Beluch has been working on <a href="http://readthedocs.org/projects/xbmcswift2/">xmbcswift2</a> over the last month or so, which he describes as &ldquo;A micro framework to enable rapid development of XBMC plugins&rdquo;. Although the library is still under development, the documentation is very complete.</p>

<p>Check out the xbmc-confreaks <a href="http://github.com/watsonbox/xbmc-confreaks">source</a>, or download the <a href="http://github.com/watsonbox/xbmc-confreaks/raw/master/release/xbmc-confreaks-0.1.zip">zip file</a> ready to be installed directly into XBMC. I&rsquo;ve only tested it with the latest stable release of XBMC 11.0 Eden.</p>
]]></content>
  </entry>
  
</feed>
