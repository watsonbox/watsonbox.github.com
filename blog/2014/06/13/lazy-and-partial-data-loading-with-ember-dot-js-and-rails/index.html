<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Lazy and Partial Data Loading with Ember.js and Rails | Watsonbox</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Lazy and Partial Data Loading with Ember.js and Rails" />
<meta name="author" content="Howard Wilson" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="While learning Ember.js, I couldn’t find all the info laid out clearly in one place on these subjects, so thought I’d write up my findings. I’m using Ember.js 1.5.1, Ember Data 1.0.0-beta.7+canary.f482da04 (!!), and Rails 4.1.0. Lazy Loading Relationships Most of the Rails/Ember guidelines out there suggest that related data should normally be sideloaded, which is great and helps reduce the number of HTTP requests required, or data duplication (in the case of embedded data). To sideload data, set up the relationship and Rails serializer as follows: app/assets/javascripts/models/project.js.coffee App.Project = DS.Model.extend name: DS.attr(&#39;string&#39;) description: DS.attr(&#39;string&#39;) invoices: DS.hasMany(&#39;invoice&#39;) app/serializers/project_serializer.rb class ProjectSerializer &lt; ActiveModel::Serializer attributes :id, :name has_many :invoices, embed: :ids, include: true # Sideload relationship end Example JSON response: { &quot;projects&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Project 1&quot;, &quot;description&quot;: &quot;...&quot;, &quot;invoice_ids&quot;: [1, 2] } ], &quot;invoices&quot;: [ { &quot;id&quot;: 2, &quot;reference&quot;: &quot;INV-002&quot;, &quot;date&quot;: &quot;2014-06-11&quot;, &quot;project_id&quot;: 1 }, { &quot;id&quot;: 1, &quot;reference&quot;: &quot;INV-001&quot;, &quot;date&quot;: &quot;2014-04-04&quot;, &quot;project_id&quot;: 1 } ] } Async Loading Often we’d prefer to lazily load the associated data only when it’s referenced. Ember Data calls this an async relationship. Simply modify the above by omitting the include serializer option and adding async to the relationship: app/assets/javascripts/models/project.js.coffee (partial) invoices: DS.hasMany(&#39;invoice&#39;, { async: true }) app/serializers/lazy_project_serializer.rb (partial) has_many :invoices, embed: :ids Example JSON response: { &quot;projects&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Project 1&quot;, &quot;description&quot;: &quot;...&quot;, &quot;invoice_ids&quot;: [1, 2] } ] } When the invoices relationship is accessed, Ember Data will automatically make a request to /invoices?ids[]=1&amp;ids[]=2 (or presumably wherever that route is defined), so the Rails InvoicesController must be set up to restrict returned data based on the ids parameter. Update 30/12/14: Since Ember Data v1.0.0-beta.9 has many coalescing has become opt-in. This means setting coalesceFindRequests: true on the REST adapter for the above behavior. Thanks to CamonZ for pointing this out. Note that if an association is set to async, but sideloaded data exists in the server response, Ember Data will simply use that data and not attempt to make another request. This is useful, allowing data to be sideloaded for a detail view because we know we’re going to need it, but not for a list view where it might not be used. When moving from list to detail, the invoices will be loaded, but when arriving directly on the detail page, only the project will be loaded. Specify a different serializer in Rails for each action: app/controllers/projects_controller.rb class ProjectsController &lt; ApplicationController respond_to :json def index respond_with Project.all, each_serializer: LazyProjectSerializer end def show respond_with Project.find(params[:id]) end end Async Loading From Links Another possibility, which gives more control over association endpoints, and avoids having to pass a bunch of IDs around, is to provide links for the relationships in the JSON response. For example: app/serializers/project_serializer.rb class ProjectSerializer &lt; ActiveModel::Serializer attributes :id, :name, :links def links { invoices: project_invoices_path(id) } end end Loading Partial Models Imagine that we have a dropdown list of projects in the page navbar. In addition to lazy loading related data, we might also want to omit attributes we know we’re not going to need yet. In this case a large project description might be a candidate for ommission from the list view, especially if the list of projects is large. The most comprehensive description of this problem I was able to find is here, and includes links to related discussions. Firstly we need to identify the list data as partial by adding a partial attribute and setting it in a PartialProjectSerializer. We also ommit the invoices and description: app/assets/javascripts/models/project.js.coffee App.Project = DS.Model.extend name: DS.attr(&#39;string&#39;) description: DS.attr(&#39;string&#39;) partial: DS.attr(&#39;boolean&#39;) invoices: DS.hasMany(&#39;invoice&#39;, { async: true }) app/serializers/partial_project_serializer.rb class PartialProjectSerializer &lt; ApplicationSerializer attributes :id, :name, :partial def partial true end end We now have two problems to solve: Reload a complete model for the detail view if we have only a partial model. Don’t allow partial list data to overwrite a complete model if it comes in afterwards. You can simulate this in your dev environment using a threaded web server such as Puma and setting a delay on the resource index. For the first we can use setupController on the project route. Modifying the model hook won’t work when a model is passed for example to link-to because it doesn’t get called. app/assets/javascripts/routes/project_route.js.coffee Facture.ProjectRoute = Ember.Route.extend model: (params) -&gt; @store.find &#39;project&#39;, params.project_id setupController: (controller, model) -&gt; # If the model is partial, we&#39;ll refresh it (from the full project resource) model.reload() if model.get &#39;partial&#39; controller.set &#39;model&#39;, model It would be nice if we could solve the second problem by asking Ember Data to retrieve and merge data from the server (using something like Store#find_and_update), but that doesn’t appear to be possible. It is however possible to update individual records using Store#update. I’ve been getting these projects in the ApplicationRoute, which now looks like this: app/assets/javascripts/routes/application.js.coffee Facture.ApplicationRoute = Ember.Route.extend setupController: (controller) -&gt; $.getJSON &#39;/projects.json&#39;, (data) =&gt; # Update records in the store projects = data[&#39;projects&#39;].map (project) =&gt; # Don&#39;t merge partial=true if existing_project = @store.getById(&#39;project&#39;, project.id) project.partial = false unless existing_project.get(&#39;partial&#39;) @store.update &#39;project&#39;, project # Set all records on the controller controller.set &#39;projects&#39;, projects" />
<meta property="og:description" content="While learning Ember.js, I couldn’t find all the info laid out clearly in one place on these subjects, so thought I’d write up my findings. I’m using Ember.js 1.5.1, Ember Data 1.0.0-beta.7+canary.f482da04 (!!), and Rails 4.1.0. Lazy Loading Relationships Most of the Rails/Ember guidelines out there suggest that related data should normally be sideloaded, which is great and helps reduce the number of HTTP requests required, or data duplication (in the case of embedded data). To sideload data, set up the relationship and Rails serializer as follows: app/assets/javascripts/models/project.js.coffee App.Project = DS.Model.extend name: DS.attr(&#39;string&#39;) description: DS.attr(&#39;string&#39;) invoices: DS.hasMany(&#39;invoice&#39;) app/serializers/project_serializer.rb class ProjectSerializer &lt; ActiveModel::Serializer attributes :id, :name has_many :invoices, embed: :ids, include: true # Sideload relationship end Example JSON response: { &quot;projects&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Project 1&quot;, &quot;description&quot;: &quot;...&quot;, &quot;invoice_ids&quot;: [1, 2] } ], &quot;invoices&quot;: [ { &quot;id&quot;: 2, &quot;reference&quot;: &quot;INV-002&quot;, &quot;date&quot;: &quot;2014-06-11&quot;, &quot;project_id&quot;: 1 }, { &quot;id&quot;: 1, &quot;reference&quot;: &quot;INV-001&quot;, &quot;date&quot;: &quot;2014-04-04&quot;, &quot;project_id&quot;: 1 } ] } Async Loading Often we’d prefer to lazily load the associated data only when it’s referenced. Ember Data calls this an async relationship. Simply modify the above by omitting the include serializer option and adding async to the relationship: app/assets/javascripts/models/project.js.coffee (partial) invoices: DS.hasMany(&#39;invoice&#39;, { async: true }) app/serializers/lazy_project_serializer.rb (partial) has_many :invoices, embed: :ids Example JSON response: { &quot;projects&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Project 1&quot;, &quot;description&quot;: &quot;...&quot;, &quot;invoice_ids&quot;: [1, 2] } ] } When the invoices relationship is accessed, Ember Data will automatically make a request to /invoices?ids[]=1&amp;ids[]=2 (or presumably wherever that route is defined), so the Rails InvoicesController must be set up to restrict returned data based on the ids parameter. Update 30/12/14: Since Ember Data v1.0.0-beta.9 has many coalescing has become opt-in. This means setting coalesceFindRequests: true on the REST adapter for the above behavior. Thanks to CamonZ for pointing this out. Note that if an association is set to async, but sideloaded data exists in the server response, Ember Data will simply use that data and not attempt to make another request. This is useful, allowing data to be sideloaded for a detail view because we know we’re going to need it, but not for a list view where it might not be used. When moving from list to detail, the invoices will be loaded, but when arriving directly on the detail page, only the project will be loaded. Specify a different serializer in Rails for each action: app/controllers/projects_controller.rb class ProjectsController &lt; ApplicationController respond_to :json def index respond_with Project.all, each_serializer: LazyProjectSerializer end def show respond_with Project.find(params[:id]) end end Async Loading From Links Another possibility, which gives more control over association endpoints, and avoids having to pass a bunch of IDs around, is to provide links for the relationships in the JSON response. For example: app/serializers/project_serializer.rb class ProjectSerializer &lt; ActiveModel::Serializer attributes :id, :name, :links def links { invoices: project_invoices_path(id) } end end Loading Partial Models Imagine that we have a dropdown list of projects in the page navbar. In addition to lazy loading related data, we might also want to omit attributes we know we’re not going to need yet. In this case a large project description might be a candidate for ommission from the list view, especially if the list of projects is large. The most comprehensive description of this problem I was able to find is here, and includes links to related discussions. Firstly we need to identify the list data as partial by adding a partial attribute and setting it in a PartialProjectSerializer. We also ommit the invoices and description: app/assets/javascripts/models/project.js.coffee App.Project = DS.Model.extend name: DS.attr(&#39;string&#39;) description: DS.attr(&#39;string&#39;) partial: DS.attr(&#39;boolean&#39;) invoices: DS.hasMany(&#39;invoice&#39;, { async: true }) app/serializers/partial_project_serializer.rb class PartialProjectSerializer &lt; ApplicationSerializer attributes :id, :name, :partial def partial true end end We now have two problems to solve: Reload a complete model for the detail view if we have only a partial model. Don’t allow partial list data to overwrite a complete model if it comes in afterwards. You can simulate this in your dev environment using a threaded web server such as Puma and setting a delay on the resource index. For the first we can use setupController on the project route. Modifying the model hook won’t work when a model is passed for example to link-to because it doesn’t get called. app/assets/javascripts/routes/project_route.js.coffee Facture.ProjectRoute = Ember.Route.extend model: (params) -&gt; @store.find &#39;project&#39;, params.project_id setupController: (controller, model) -&gt; # If the model is partial, we&#39;ll refresh it (from the full project resource) model.reload() if model.get &#39;partial&#39; controller.set &#39;model&#39;, model It would be nice if we could solve the second problem by asking Ember Data to retrieve and merge data from the server (using something like Store#find_and_update), but that doesn’t appear to be possible. It is however possible to update individual records using Store#update. I’ve been getting these projects in the ApplicationRoute, which now looks like this: app/assets/javascripts/routes/application.js.coffee Facture.ApplicationRoute = Ember.Route.extend setupController: (controller) -&gt; $.getJSON &#39;/projects.json&#39;, (data) =&gt; # Update records in the store projects = data[&#39;projects&#39;].map (project) =&gt; # Don&#39;t merge partial=true if existing_project = @store.getById(&#39;project&#39;, project.id) project.partial = false unless existing_project.get(&#39;partial&#39;) @store.update &#39;project&#39;, project # Set all records on the controller controller.set &#39;projects&#39;, projects" />
<meta property="og:site_name" content="Watsonbox" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-06-13T14:43:13+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lazy and Partial Data Loading with Ember.js and Rails" />
<script type="application/ld+json">
{"url":"/blog/2014/06/13/lazy-and-partial-data-loading-with-ember-dot-js-and-rails/","headline":"Lazy and Partial Data Loading with Ember.js and Rails","dateModified":"2014-06-13T14:43:13+02:00","datePublished":"2014-06-13T14:43:13+02:00","author":{"@type":"Person","name":"Howard Wilson"},"mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2014/06/13/lazy-and-partial-data-loading-with-ember-dot-js-and-rails/"},"description":"While learning Ember.js, I couldn’t find all the info laid out clearly in one place on these subjects, so thought I’d write up my findings. I’m using Ember.js 1.5.1, Ember Data 1.0.0-beta.7+canary.f482da04 (!!), and Rails 4.1.0. Lazy Loading Relationships Most of the Rails/Ember guidelines out there suggest that related data should normally be sideloaded, which is great and helps reduce the number of HTTP requests required, or data duplication (in the case of embedded data). To sideload data, set up the relationship and Rails serializer as follows: app/assets/javascripts/models/project.js.coffee App.Project = DS.Model.extend name: DS.attr(&#39;string&#39;) description: DS.attr(&#39;string&#39;) invoices: DS.hasMany(&#39;invoice&#39;) app/serializers/project_serializer.rb class ProjectSerializer &lt; ActiveModel::Serializer attributes :id, :name has_many :invoices, embed: :ids, include: true # Sideload relationship end Example JSON response: { &quot;projects&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Project 1&quot;, &quot;description&quot;: &quot;...&quot;, &quot;invoice_ids&quot;: [1, 2] } ], &quot;invoices&quot;: [ { &quot;id&quot;: 2, &quot;reference&quot;: &quot;INV-002&quot;, &quot;date&quot;: &quot;2014-06-11&quot;, &quot;project_id&quot;: 1 }, { &quot;id&quot;: 1, &quot;reference&quot;: &quot;INV-001&quot;, &quot;date&quot;: &quot;2014-04-04&quot;, &quot;project_id&quot;: 1 } ] } Async Loading Often we’d prefer to lazily load the associated data only when it’s referenced. Ember Data calls this an async relationship. Simply modify the above by omitting the include serializer option and adding async to the relationship: app/assets/javascripts/models/project.js.coffee (partial) invoices: DS.hasMany(&#39;invoice&#39;, { async: true }) app/serializers/lazy_project_serializer.rb (partial) has_many :invoices, embed: :ids Example JSON response: { &quot;projects&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Project 1&quot;, &quot;description&quot;: &quot;...&quot;, &quot;invoice_ids&quot;: [1, 2] } ] } When the invoices relationship is accessed, Ember Data will automatically make a request to /invoices?ids[]=1&amp;ids[]=2 (or presumably wherever that route is defined), so the Rails InvoicesController must be set up to restrict returned data based on the ids parameter. Update 30/12/14: Since Ember Data v1.0.0-beta.9 has many coalescing has become opt-in. This means setting coalesceFindRequests: true on the REST adapter for the above behavior. Thanks to CamonZ for pointing this out. Note that if an association is set to async, but sideloaded data exists in the server response, Ember Data will simply use that data and not attempt to make another request. This is useful, allowing data to be sideloaded for a detail view because we know we’re going to need it, but not for a list view where it might not be used. When moving from list to detail, the invoices will be loaded, but when arriving directly on the detail page, only the project will be loaded. Specify a different serializer in Rails for each action: app/controllers/projects_controller.rb class ProjectsController &lt; ApplicationController respond_to :json def index respond_with Project.all, each_serializer: LazyProjectSerializer end def show respond_with Project.find(params[:id]) end end Async Loading From Links Another possibility, which gives more control over association endpoints, and avoids having to pass a bunch of IDs around, is to provide links for the relationships in the JSON response. For example: app/serializers/project_serializer.rb class ProjectSerializer &lt; ActiveModel::Serializer attributes :id, :name, :links def links { invoices: project_invoices_path(id) } end end Loading Partial Models Imagine that we have a dropdown list of projects in the page navbar. In addition to lazy loading related data, we might also want to omit attributes we know we’re not going to need yet. In this case a large project description might be a candidate for ommission from the list view, especially if the list of projects is large. The most comprehensive description of this problem I was able to find is here, and includes links to related discussions. Firstly we need to identify the list data as partial by adding a partial attribute and setting it in a PartialProjectSerializer. We also ommit the invoices and description: app/assets/javascripts/models/project.js.coffee App.Project = DS.Model.extend name: DS.attr(&#39;string&#39;) description: DS.attr(&#39;string&#39;) partial: DS.attr(&#39;boolean&#39;) invoices: DS.hasMany(&#39;invoice&#39;, { async: true }) app/serializers/partial_project_serializer.rb class PartialProjectSerializer &lt; ApplicationSerializer attributes :id, :name, :partial def partial true end end We now have two problems to solve: Reload a complete model for the detail view if we have only a partial model. Don’t allow partial list data to overwrite a complete model if it comes in afterwards. You can simulate this in your dev environment using a threaded web server such as Puma and setting a delay on the resource index. For the first we can use setupController on the project route. Modifying the model hook won’t work when a model is passed for example to link-to because it doesn’t get called. app/assets/javascripts/routes/project_route.js.coffee Facture.ProjectRoute = Ember.Route.extend model: (params) -&gt; @store.find &#39;project&#39;, params.project_id setupController: (controller, model) -&gt; # If the model is partial, we&#39;ll refresh it (from the full project resource) model.reload() if model.get &#39;partial&#39; controller.set &#39;model&#39;, model It would be nice if we could solve the second problem by asking Ember Data to retrieve and merge data from the server (using something like Store#find_and_update), but that doesn’t appear to be possible. It is however possible to update individual records using Store#update. I’ve been getting these projects in the ApplicationRoute, which now looks like this: app/assets/javascripts/routes/application.js.coffee Facture.ApplicationRoute = Ember.Route.extend setupController: (controller) -&gt; $.getJSON &#39;/projects.json&#39;, (data) =&gt; # Update records in the store projects = data[&#39;projects&#39;].map (project) =&gt; # Don&#39;t merge partial=true if existing_project = @store.getById(&#39;project&#39;, project.id) project.partial = false unless existing_project.get(&#39;partial&#39;) @store.update &#39;project&#39;, project # Set all records on the controller controller.set &#39;projects&#39;, projects","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Watsonbox" />
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">
      <img src="/assets/images/watsonbox.png" />
    </a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/">Blog</a><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Lazy and Partial Data Loading with Ember.js and Rails</h1>
    <p class="post-meta"><time class="dt-published" datetime="2014-06-13T14:43:13+02:00" itemprop="datePublished">
        Jun 13, 2014
      </time> |
        
          <code class="highlighter-rouge"><a class="post-tag" href="/tags/#ember-js">Ember.js</a></code>
        
          <code class="highlighter-rouge"><a class="post-tag" href="/tags/#ruby">Ruby</a></code>
        
          <code class="highlighter-rouge"><a class="post-tag" href="/tags/#rails">Rails</a></code>
        
      • 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Howard Wilson</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>While learning <a href="http://emberjs.com/">Ember.js</a>, I couldn’t find all the info laid out clearly in one place on these subjects, so thought I’d write up my findings. I’m using Ember.js 1.5.1, Ember Data 1.0.0-beta.7+canary.f482da04 (!!), and Rails 4.1.0.</p>

<h2 id="lazy-loading-relationships">Lazy Loading Relationships</h2>

<p>Most of the <a href="http://emberjs.com/api/data/classes/DS.ActiveModelSerializer.html">Rails/Ember guidelines</a> out there suggest that related data should normally be sideloaded, which is great and helps reduce the number of HTTP requests required, or data duplication (in the case of embedded data). To sideload data, set up the relationship and Rails serializer as follows:</p>

<p><code class="language-plaintext highlighter-rouge">app/assets/javascripts/models/project.js.coffee</code></p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">App</span><span class="p">.</span><span class="na">Project</span> <span class="o">=</span> <span class="nx">DS</span><span class="p">.</span><span class="na">Model</span><span class="p">.</span><span class="na">extend</span>
  <span class="na">name</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">attr</span><span class="p">(</span><span class="s">'string'</span><span class="p">)</span>
  <span class="na">description</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">attr</span><span class="p">(</span><span class="s">'string'</span><span class="p">)</span>
  <span class="na">invoices</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">hasMany</span><span class="p">(</span><span class="s">'invoice'</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">app/serializers/project_serializer.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProjectSerializer</span> <span class="o">&lt;</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Serializer</span>
  <span class="n">attributes</span> <span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span>
  <span class="n">has_many</span> <span class="ss">:invoices</span><span class="p">,</span> <span class="ss">embed: :ids</span><span class="p">,</span> <span class="ss">include: </span><span class="kp">true</span> <span class="c1"># Sideload relationship</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Example JSON response:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"projects"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w"> </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Project 1"</span><span class="p">,</span><span class="w"> </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="p">,</span><span class="w"> </span><span class="nl">"invoice_ids"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"invoices"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w"> </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nl">"reference"</span><span class="p">:</span><span class="w"> </span><span class="s2">"INV-002"</span><span class="p">,</span><span class="w"> </span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2014-06-11"</span><span class="p">,</span><span class="w"> </span><span class="nl">"project_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w"> </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"reference"</span><span class="p">:</span><span class="w"> </span><span class="s2">"INV-001"</span><span class="p">,</span><span class="w"> </span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2014-04-04"</span><span class="p">,</span><span class="w"> </span><span class="nl">"project_id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="async-loading">Async Loading</h3>

<p>Often we’d prefer to lazily load the associated data only when it’s referenced. Ember Data calls this an async relationship. Simply modify the above by omitting the <code class="language-plaintext highlighter-rouge">include</code> serializer option and adding <code class="language-plaintext highlighter-rouge">async</code> to the relationship:</p>

<p><code class="language-plaintext highlighter-rouge">app/assets/javascripts/models/project.js.coffee</code> (partial)</p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">invoices</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">hasMany</span><span class="p">(</span><span class="s">'invoice'</span><span class="p">,</span> <span class="p">{</span> <span class="na">async</span><span class="o">:</span> <span class="no">true</span> <span class="p">})</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">app/serializers/lazy_project_serializer.rb</code> (partial)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">has_many</span> <span class="ss">:invoices</span><span class="p">,</span> <span class="ss">embed: :ids</span>
</code></pre></div></div>

<p>Example JSON response:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"projects"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w"> </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Project 1"</span><span class="p">,</span><span class="w"> </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="p">,</span><span class="w"> </span><span class="nl">"invoice_ids"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>When the <code class="language-plaintext highlighter-rouge">invoices</code> relationship is accessed, Ember Data will automatically make a request to <code class="language-plaintext highlighter-rouge">/invoices?ids[]=1&amp;ids[]=2</code> (or presumably wherever that route is defined), so the Rails <code class="language-plaintext highlighter-rouge">InvoicesController</code> must be set up to restrict returned data based on the <code class="language-plaintext highlighter-rouge">ids</code> parameter.</p>

<p><em>Update 30/12/14: Since Ember Data v1.0.0-beta.9 <a href="http://emberjs.com/blog/2014/08/18/ember-data-1-0-beta-9-released.html">has many coalescing has become opt-in</a>. This means setting <code class="language-plaintext highlighter-rouge">coalesceFindRequests: true</code> on the REST adapter for the above behavior. Thanks to CamonZ for pointing this out.</em></p>

<p>Note that if an association is set to <code class="language-plaintext highlighter-rouge">async</code>, but sideloaded data exists in the server response, Ember Data will simply use that data and not attempt to make another request. This is useful, allowing data to be sideloaded for a detail view because we know we’re going to need it, but not for a list view where it might not be used. When moving from list to detail, the invoices will be loaded, but when arriving directly on the detail page, only the project will be loaded. Specify a different serializer in Rails for each action:</p>

<p><code class="language-plaintext highlighter-rouge">app/controllers/projects_controller.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProjectsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">respond_to</span> <span class="ss">:json</span>

  <span class="k">def</span> <span class="nf">index</span>
    <span class="n">respond_with</span> <span class="no">Project</span><span class="p">.</span><span class="nf">all</span><span class="p">,</span> <span class="ss">each_serializer: </span><span class="no">LazyProjectSerializer</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="n">respond_with</span> <span class="no">Project</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="async-loading-from-links">Async Loading From Links</h3>

<p>Another possibility, which gives more control over association endpoints, and avoids having to pass a bunch of IDs around, is to provide links for the relationships in the JSON response. For example:</p>

<p><code class="language-plaintext highlighter-rouge">app/serializers/project_serializer.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProjectSerializer</span> <span class="o">&lt;</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Serializer</span>
  <span class="n">attributes</span> <span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:links</span>

  <span class="k">def</span> <span class="nf">links</span>
    <span class="p">{</span> <span class="ss">invoices: </span><span class="n">project_invoices_path</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="loading-partial-models">Loading Partial Models</h2>

<p>Imagine that we have a dropdown list of projects in the page navbar. In addition to lazy loading related data, we might also want to omit attributes we know we’re not going to need yet. In this case a large project description might be a candidate for ommission from the list view, especially if the list of projects is large. The most comprehensive description of this problem I was able to find is <a href="http://discuss.emberjs.com/t/loading-partial-models-then-filling-them-with-ember-data/819">here</a>, and includes links to related discussions.</p>

<p>Firstly we need to identify the list data as partial by adding a <code class="language-plaintext highlighter-rouge">partial</code> attribute and setting it in a <code class="language-plaintext highlighter-rouge">PartialProjectSerializer</code>. We also ommit the invoices and description:</p>

<p><code class="language-plaintext highlighter-rouge">app/assets/javascripts/models/project.js.coffee</code></p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">App</span><span class="p">.</span><span class="na">Project</span> <span class="o">=</span> <span class="nx">DS</span><span class="p">.</span><span class="na">Model</span><span class="p">.</span><span class="na">extend</span>
  <span class="na">name</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">attr</span><span class="p">(</span><span class="s">'string'</span><span class="p">)</span>
  <span class="na">description</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">attr</span><span class="p">(</span><span class="s">'string'</span><span class="p">)</span>
  <span class="na">partial</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">attr</span><span class="p">(</span><span class="s">'boolean'</span><span class="p">)</span>
  <span class="na">invoices</span><span class="o">:</span> <span class="nx">DS</span><span class="p">.</span><span class="na">hasMany</span><span class="p">(</span><span class="s">'invoice'</span><span class="p">,</span> <span class="p">{</span> <span class="na">async</span><span class="o">:</span> <span class="no">true</span> <span class="p">})</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">app/serializers/partial_project_serializer.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PartialProjectSerializer</span> <span class="o">&lt;</span> <span class="no">ApplicationSerializer</span>
  <span class="n">attributes</span> <span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:partial</span>

  <span class="k">def</span> <span class="nf">partial</span>
    <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We now have two problems to solve:</p>

<ol>
  <li>Reload a complete model for the detail view if we have only a partial model.</li>
  <li>Don’t allow partial list data to overwrite a complete model if it comes in afterwards. You can simulate this in your dev environment using a threaded web server such as Puma and setting a delay on the resource index.</li>
</ol>

<p>For the first we can use <code class="language-plaintext highlighter-rouge">setupController</code> on the project route. Modifying the <code class="language-plaintext highlighter-rouge">model</code> hook won’t work when a model is passed for example to <code class="language-plaintext highlighter-rouge">link-to</code> because it <a href="http://emberjs.com/guides/routing/asynchronous-routing/#toc_beforemodel-and-aftermodel">doesn’t get called</a>.</p>

<p><code class="language-plaintext highlighter-rouge">app/assets/javascripts/routes/project_route.js.coffee</code></p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Facture</span><span class="p">.</span><span class="na">ProjectRoute</span> <span class="o">=</span> <span class="nx">Ember</span><span class="p">.</span><span class="na">Route</span><span class="p">.</span><span class="na">extend</span>
  <span class="na">model</span><span class="o">:</span> <span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="vi">@</span><span class="na">store</span><span class="p">.</span><span class="na">find</span> <span class="s">'project'</span><span class="p">,</span> <span class="nx">params</span><span class="p">.</span><span class="na">project_id</span>

  <span class="na">setupController</span><span class="o">:</span> <span class="p">(</span><span class="nx">controller</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="c1"># If the model is partial, we'll refresh it (from the full project resource)</span>
    <span class="nx">model</span><span class="p">.</span><span class="na">reload</span><span class="p">()</span> <span class="k">if</span> <span class="nx">model</span><span class="p">.</span><span class="na">get</span> <span class="s">'partial'</span>
    <span class="nx">controller</span><span class="p">.</span><span class="na">set</span> <span class="s">'model'</span><span class="p">,</span> <span class="nx">model</span>
</code></pre></div></div>

<p>It would be nice if we could solve the second problem by asking Ember Data to retrieve and <em>merge</em> data from the server (using something like <code class="language-plaintext highlighter-rouge">Store#find_and_update</code>), but that doesn’t appear to be possible. It is however possible to update individual records using <a href="http://emberjs.com/api/data/classes/DS.Store.html#method_update"><code class="language-plaintext highlighter-rouge">Store#update</code></a>.</p>

<p>I’ve been getting these projects in the <code class="language-plaintext highlighter-rouge">ApplicationRoute</code>, which now looks like this:</p>

<p><code class="language-plaintext highlighter-rouge">app/assets/javascripts/routes/application.js.coffee</code></p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Facture</span><span class="p">.</span><span class="na">ApplicationRoute</span> <span class="o">=</span> <span class="nx">Ember</span><span class="p">.</span><span class="na">Route</span><span class="p">.</span><span class="na">extend</span>
  <span class="na">setupController</span><span class="o">:</span> <span class="p">(</span><span class="nx">controller</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nx">$</span><span class="p">.</span><span class="na">getJSON</span> <span class="s">'/projects.json'</span><span class="p">,</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="c1"># Update records in the store</span>
      <span class="nx">projects</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="s">'projects'</span><span class="p">].</span><span class="na">map</span> <span class="p">(</span><span class="nx">project</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="c1"># Don't merge partial=true</span>
        <span class="k">if</span> <span class="nx">existing_project</span> <span class="o">=</span> <span class="vi">@</span><span class="na">store</span><span class="p">.</span><span class="na">getById</span><span class="p">(</span><span class="s">'project'</span><span class="p">,</span> <span class="nx">project</span><span class="p">.</span><span class="na">id</span><span class="p">)</span>
          <span class="nx">project</span><span class="p">.</span><span class="na">partial</span> <span class="o">=</span> <span class="no">false</span> <span class="nx">unless</span> <span class="nx">existing_project</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">'partial'</span><span class="p">)</span>

        <span class="vi">@</span><span class="na">store</span><span class="p">.</span><span class="na">update</span> <span class="s">'project'</span><span class="p">,</span> <span class="nx">project</span>

      <span class="c1"># Set all records on the controller</span>
      <span class="nx">controller</span><span class="p">.</span><span class="na">set</span> <span class="s">'projects'</span><span class="p">,</span> <span class="nx">projects</span>
</code></pre></div></div>

  </div><a class="u-url" href="/blog/2014/06/13/lazy-and-partial-data-loading-with-ember-dot-js-and-rails/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Howard Wilson</li>
          <li><a class="u-email" href="mailto:howard@watsonbox.net">howard@watsonbox.net</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Watsonbox Blog
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/watsonbox" title="watsonbox"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/watsonbox" title="watsonbox"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://twitter.com/jekyllrb" title="jekyllrb"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
